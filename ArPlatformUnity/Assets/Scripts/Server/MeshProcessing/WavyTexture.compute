// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel clear_rasterizer_texture
#pragma kernel rasterize
#pragma enable_d3d11_debug_symbols

//types


//a point on the mesh that is 
struct MeshHit
{
    float2 uv; //the uv coordinate of texture of the mesh that was hit
    uint depth; //the depth of the hit away from the camera
    uint2 screenPos; //the pixel coordinate of the photo
    uint meshIndex; //the index of the mesh that was hit
};

struct Vertex
{
    float3 position;
    float3 normal;
    float2 uv;
};

struct Triangle
{
    uint vertexIndex1;
    uint vertexIndex2;
    uint vertexIndex3;
};

struct Mesh
{
    uint index;
    uint vertexOffset;
    uint triangleOffset;
    uint vertexCount;
    uint triangleCount;
};

//global buffers and properties


StructuredBuffer<Mesh> meshes;
StructuredBuffer<Vertex> vertices;
StructuredBuffer<Triangle> triangles;


Texture2D<float3> inputPhoto; //the photo that will be projected onto the mesh
RWTexture2D<float4> rasterizerDepthTexture; //debug view of the rasterizer meshHitsTexture
StructuredBuffer<MeshHit> meshHitsTexture; //technically the output texture of the rasterizer
int2 inputResolution; //the resolution of the input image
float4x4 worldToCameraMatrix; //the world to camera matrix


RWTexture2D<float4> meshTexture; //the texture of the mesh that will get new colors
int2 meshTextureResolution; //the resolution of the mesh texture
int meshId; //the id of the mesh that will be modified

float3 project(float3 v)
{
    float4 transformed = mul(worldToCameraMatrix, float4(v, 1));
    float3 vector3 = transformed.xyz;
    // Normalize the vector
    float num = 1.0f / transformed.w;
    vector3 *= num;
    return vector3;
}

uint index_of(uint x, uint y, int2 resolution)
{
    return y * resolution.x + x;
}

float4 get_min_max(float3 v1, float3 v2, float3 v3)
{
    float4 min_max;

    min_max.x = min(min(v1.x, v2.x), v3.x);
    min_max.y = min(min(v1.y, v2.y), v3.y);
    min_max.z = max(max(v1.x, v2.x), v3.x);
    min_max.w = max(max(v1.y, v2.y), v3.y);

    return min_max;
}

float3 barycentric(float3 v1, float3 v2, float3 v3, float2 p)
{
    float3 u = cross(
        float3(v3.x - v1.x, v2.x - v1.x, v1.x - p.x),
        float3(v3.y - v1.y, v2.y - v1.y, v1.y - p.y)
    );

    if (abs(u.z) < 1.0)
    {
        return float3(-1.0, 1.0, 1.0);
    }

    return float3(1.0 - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);
}

bool is_on_screen(float3 v)
{
    return (v.x > -1 && v.x < 1 && v.y > -1 && v.y < 1 && v.z > -1 && v.z < 1);
}

float2 to_screen_space(float2 v)
{
    return (v + 1.0f) / 2.0f * inputResolution;
}
void color_pixel(uint2 pos,float4 color)
{
    if(rasterizerDepthTexture[pos].a>color.a)
    {
        rasterizerDepthTexture[pos]=color;
    }
}

void draw_circle(uint2 pos, int radius, float4 color)
{
    int2 topLeft = int2(pos) - radius;
    int2 bottomRight = int2(pos) + radius;
    topLeft = clamp(topLeft, 0, inputResolution);
    bottomRight = clamp(bottomRight, 0, inputResolution);

    float2 center = float2(pos);
    for (int x = topLeft.x; x < bottomRight.x; x++)
    {
        for (int y = topLeft.y; y < bottomRight.y; y++)
        {
            float2 pixel = float2(x, y);
            float dist = distance(pixel, center);
            if (dist < radius)
            {
                rasterizerDepthTexture[pixel] = color;
            }
        }
    }
}

void draw_line(uint2 p1, uint2 p2, float4 color)
{
    int2 pos1 = clamp(p1, 0, inputResolution);
    int2 pos2 = clamp(p2, 0, inputResolution);
    int steps = max(abs(pos1.x - pos2.x), abs(pos1.y - pos2.y));
    float2 position = float2(pos1);
    float2 step = (float2(pos2) - float2(pos1)) / steps;
    for (int i = 0; i < steps; i++)
    {
        rasterizerDepthTexture[position] = color;
        rasterizerDepthTexture[uint2(position.x, position.y + 1)] = color;
        rasterizerDepthTexture[uint2(position.x, position.y - 1)] = color;
        rasterizerDepthTexture[uint2(position.x + 1, position.y)] = color;
        rasterizerDepthTexture[uint2(position.x - 1, position.y)] = color;
        position += step;
    }
}

void draw_triangle(float3 p1, float3 p2, float3 p3, Vertex v1, Vertex v2, Vertex v3,bool is_correct_mesh)
{
    p1 = float3(to_screen_space(p1.xy),p1.z);
    p2 = float3(to_screen_space(p2.xy),p2.z);
    p3 = float3(to_screen_space(p3.xy),p3.z);
    float4 min_max = get_min_max(p1, p2, p3);
    uint startX = uint(min_max.x);
    uint startY = uint(min_max.y);
    uint endX = uint(min_max.z);
    uint endY = uint(min_max.w);
    for (uint x = startX; x <= endX; x = x + 1u)
    {
        for (uint y = startY; y <= endY; y = y + 1u)
        {
            float3 bc = barycentric(p1, p2, p3, float2(float(x), float(y)));

            if (bc.x < 0.0 || bc.y < 0.0 || bc.z < 0.0)
            {
                continue;
            }
            //color from normal
            float3 color = normalize(v1.normal + v2.normal + v3.normal);
            float depth = bc.x * p1.z + bc.y * p2.z + bc.z * p3.z;
            //color_pixel(uint2(x, y), float4(color, depth));
            
            float2 uv = v1.uv * bc.x + v2.uv * bc.y + v3.uv * bc.z;
            uint2 mesh_texture_coord = uint2(uv * float2(meshTextureResolution));
            if(is_correct_mesh)
            {
                //meshTexture[mesh_texture_coord] = float4(color, 1);
                float3 input_color=inputPhoto[uint2(x,y)];
                meshTexture[mesh_texture_coord] = float4(input_color, 1);
            }
        }
    }
}


//kernels
//clear stage for meshHits
[numthreads(8, 8, 1)]
void clear_rasterizer_texture(uint3 id : SV_DispatchThreadID)
{
    //important that depth is 0, this indicates that the pixel was not hit
    MeshHit notHit;
    notHit.depth = 0;
    notHit.uv = float2(0, 0);
    notHit.screenPos = uint2(0, 0);
    notHit.meshIndex = 0;

    if (id.x < inputResolution.x && id.y < inputResolution.y)
    {
        //meshHitsTexture[index_of(id.x, id.y, inputResolution)] = notHit;
        //rasterizerDepthTexture[id.xy] = float4(1.0, 0, 0, 1.0);
    }
    //give texture 2d sine wave color
    //meshTexture[id.xy] = float4(sin(id.x / 10.0), sin(id.y / 10.0), 0, 1.0);
    meshTexture[id.xy] = float4(1,1,1, 1.0);
}


//rasterize the meshes
[numthreads(64, 1, 1)]
void rasterize(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    triangles.GetDimensions(count, stride);
    if (id.x >= count)
    {
        return;
    }
    //get mesh that the current vertex belongs to
    Mesh mesh;
    int meshIndex = 0;
    meshes.GetDimensions(count,stride);
    for(int i=0;i<count;i++)
    {
        mesh=meshes[i];
        meshIndex=i;
        if(mesh.triangleOffset<=id.x&&mesh.triangleOffset+mesh.triangleCount>id.x)
        {
            break;
        }
    }
    Triangle triang = triangles[id.x];
    Vertex v1 = vertices[triang.vertexIndex1+mesh.vertexOffset];
    Vertex v2 = vertices[triang.vertexIndex2+mesh.vertexOffset];
    Vertex v3 = vertices[triang.vertexIndex3+mesh.vertexOffset];
    
    float3 p1 = project(v1.position);
    float3 p2 = project(v2.position);
    float3 p3 = project(v3.position);

    if (!is_on_screen(p1) && !is_on_screen(p2) && !is_on_screen(p3))
    {
        return;
    }
    //draw_circle(to_screen_space(p1.xy), 20, float4(0, 1, 0, 1));
    //draw_circle(to_screen_space(p2.xy), 20, float4(0, 1, 0, 1));
    //draw_circle(to_screen_space(p3.xy), 20, float4(0, 1, 0, 1));
    //draw_line(to_screen_space(p1.xy), to_screen_space(p2.xy), float4(0, 1, 0, 1));
    //draw_line(to_screen_space(p2.xy), to_screen_space(p3.xy), float4(0, 1, 0, 1));
    //draw_line(to_screen_space(p3.xy), to_screen_space(p1.xy), float4(0, 1, 0, 1));

    draw_triangle(p1, p2, p3, v1, v2, v3,meshIndex==meshId);
}
